---
title: "Noter til vejledning"
author: "Anders G. Kristensen"
date: "12032024"
format: html
editor: visual
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
options(tidyverse.quiet = TRUE)
library(tidyverse)
setwd('..')
source("source_code/tipping_simulations.R")
source("source_code/model_fitting.R")
source("source_code/model_diagnostics.R")
ggplot2::theme_set(ggthemes::theme_base())
AMOCdata <- read_table("data/AMOCdata.txt")
names(AMOCdata) <- c("time", "AMOC0", "AMOC1", "AMOC2", "GM")

```

# Den overordnede model

#### Matematisk formulering

```{=tex}
\begin{align}
\mathrm{d}X_t &= -\left(A\left(X_t - m\right)^2 + \lambda_t\right)\mathrm{d}t + \sigma X_t^\kappa \mathrm{d}W_t,\\ \lambda_t &= \lambda_0\left(1-\frac{\max(t-t_0,0)}{\tau_c}\right)^\nu, \nu > 0.
&
\end{align}
```
Med $\kappa \in\{0, 0.5 , 1\}$

Alternativt, kan vi muligvis bruge splines eller kovariater til $\lambda_t$.

#### Eksempel på simulering og fitting med $\kappa = 0.5$

##### Simulation

Simulér med $A = 0.5$, $m = 0.5$, $\lambda_0 = -3$, $\sigma = 0.5$ og $\nu = 0.55$.

```{r}
# Square-root noise model
set.seed(100)
true_param <- c(0.5, 0.5, -3, 0.5 , 0.55)
actual_dt <- 0.05
tau <- 100
t_0 <- 50
sim_res_sqrt <- simulate_squareroot_noise_tipping_model(actual_dt,
                                                        true_param,
                                                        tau, t_0)
```

```{r, echo=FALSE}
sim_res_sqrt |>  dplyr::sample_n(base::min(base::nrow(sim_res_sqrt), 5000)) |>
          ggplot2::ggplot(ggplot2::aes(x = t, y = X_weak_2.0)) + 
          ggplot2::geom_step() + 
          ggplot2::geom_hline(yintercept = true_param[2], linetype = "dashed") +
          ggplot2::geom_vline(xintercept = c(t_0, tau + t_0), linetype = "dashed") +
          ggplot2::ylab("X_t")

sim_res_sqrt |>  sample_n(min(nrow(sim_res_sqrt), 5000)) |>
          ggplot2::ggplot(ggplot2::aes(x = t, y = lambda_t)) + ggplot2::geom_step() + 
          ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
          ggplot2::geom_vline(xintercept = c(t_0, tau + t_0))
```

##### Fitting og validering

###### Stationære del af processen

```{r, echo=FALSE}
mu0 = true_param[2] + sqrt(abs(true_param[3]) / true_param[1])
alpha0 <- 2 * sqrt(true_param[1] * abs(true_param[3]))
stationary_part_true_param <- c(alpha0, mu0, true_param[4])
CIR_stationary_part_estimated_param_martingale <- CIR_quadratic_martingale(sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t < t_0], actual_dt)

cat("Procentuel afvigelse fra sande parametre: ",(CIR_stationary_part_estimated_param_martingale - stationary_part_true_param) / stationary_part_true_param * 100)

tibble::tibble(obsSample = CIR_quadratic_martingale_resid(
                              sample(sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t < t_0], size = 250,
                                     replace = FALSE),
                              data = sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t < t_0],
                              delta = actual_dt)) |>
                              ggplot2::ggplot(ggplot2::aes(sample = obsSample)) +
                              ggplot2::geom_qq() + ggplot2::geom_qq_line() +
                              ggplot2::ylab("Empirical quantiles") +
                              ggplot2::xlab("Theoretical quantiles")
```

###### Dynamiske del af processen misspecificeret med $\nu = 1$.

```{r, echo=FALSE}
dynamic_part_true_param <- c(tau, true_param[1])
CIR_dynamic_part_estimated_param_strang <- 
                            optimize_dynamic_likelihood(likelihood_fun = CIR_dynamic_likelihood,
                            data = sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t > t_0],
                            init_par = dynamic_part_true_param,
                            delta = actual_dt,
                            alpha0 = CIR_stationary_part_estimated_param_martingale[1],
                            mu0 = CIR_stationary_part_estimated_param_martingale[2],
                            sigma = CIR_stationary_part_estimated_param_martingale[3])

cat("Procentuel afvigelse fra sande parametre: ",(CIR_dynamic_part_estimated_param_strang - dynamic_part_true_param) / dynamic_part_true_param * 100)

tibble::tibble(obsSample = CIR_dynamic_likelihood_resid(CIR_dynamic_part_estimated_param_strang,
                             data = sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t > t_0],
                             delta = actual_dt,
                             alpha0 = CIR_stationary_part_estimated_param_martingale[1],
                             mu0 = CIR_stationary_part_estimated_param_martingale[2],
                             sigma = CIR_stationary_part_estimated_param_martingale[3])) |>
                             sample_n(min(floor(nrow(sim_res_sqrt)/3) - 1, 10000)) |>
                             ggplot2::ggplot(ggplot2::aes(sample = obsSample)) +
                             ggplot2::geom_qq() + ggplot2::geom_qq_line() +
                             ggplot2::ylab("Empirical quantiles") +
                             ggplot2::xlab("Theoretical quantiles")
```

###### Dynamisk del - korrekt specificeret

```{r, echo=FALSE}
dynamic_part_true_param <- c(tau, true_param[1], true_param[5])
CIR_dynamic_part_estimated_param_strang <- 
                            optimize_dynamic_likelihood(likelihood_fun = CIR_dynamic_likelihood,
                            data = sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t > t_0],
                            init_par = dynamic_part_true_param,
                            delta = actual_dt,
                            alpha0 = CIR_stationary_part_estimated_param_martingale[1],
                            mu0 = CIR_stationary_part_estimated_param_martingale[2],
                            sigma = CIR_stationary_part_estimated_param_martingale[3])

cat("Procentuel afvigelse fra sande parametre: ",(CIR_dynamic_part_estimated_param_strang - dynamic_part_true_param) / dynamic_part_true_param * 100)

tibble::tibble(obsSample = CIR_dynamic_likelihood_resid(CIR_dynamic_part_estimated_param_strang,
                             data = sim_res_sqrt$X_weak_2.0[sim_res_sqrt$t > t_0],
                             delta = actual_dt,
                             alpha0 = CIR_stationary_part_estimated_param_martingale[1],
                             mu0 = CIR_stationary_part_estimated_param_martingale[2],
                             sigma = CIR_stationary_part_estimated_param_martingale[3])) |>
                             sample_n(min(floor(nrow(sim_res_sqrt)/3) - 1, 10000)) |>
                             ggplot2::ggplot(ggplot2::aes(sample = obsSample)) +
                             ggplot2::geom_qq() + ggplot2::geom_qq_line() +
                             ggplot2::ylab("Empirical quantiles") +
                             ggplot2::xlab("Theoretical quantiles")
```

# Punkter fra mailen

#### 1-2. Modelvalideringsmetoder til simulerede likelihoods og Strang vs simulerede likelihood

Den simulerede likelihood ser sådan ud

```{r, echo=TRUE, eval=FALSE}
OU_dynamic_simulation_likelihood <- function(par, data, times, M, N,
                                             alpha0, mu0, sigma, t_0){
  tau <- par[1]
  A   <- par[2]
  nu  <- if(length(par) == 3) par[3] else 1
  
  m_tip   <- mu0 - alpha0/(2 * A)
  lambda0 <- -alpha0^2 / (4 * A)
  delta   <- 1 / M
  #time   <- delta * (1:(N-1))
  lam_seq <- lambda0 * (1 - (times[-length(times)]-t_0) / tau)^nu
  lam_mat <- t(matrix(rep(lam_seq, length.out = N * length(lam_seq)),
                      nrow = length(lam_seq), ncol = N))
  # Number of data points
  numData <- length(data) - 1
  
  
  dW <- array(dqrng::dqrnorm(N * M * numData, mean = 0, sd = sqrt(delta)),
              dim = c(M, N, numData))
  # Initialize the process array
  X  <- array(NA, dim = c(M, N, numData))
  
  X[1, , ] <- rep(data[-length(data)], each = N)
  for (m in 2:M){
    X[m, , ] <- X[m - 1, , ] - (A * (X[m - 1, , ] - m_tip)^2 + lam_mat) *
      delta + sigma * dW[m - 1, , ]
  }
  
  second_to_last_X <- t(X[M - 1, , ])
  
  sigma_t   <- sigma * sqrt(delta)
  
  mu_t      <- data[1:numData] -
    (A * (second_to_last_X - m_tip)^2 + lam_seq) * delta
  
  densities <- dnorm(data[-1], mean = mu_t, sd = sigma_t, log = TRUE)

  loglik    <- -mean(colMeans(densities))
  if(is.na(loglik) | is.infinite(loglik)){
    print("NA Likelihood")
    return(1000000)
  }
  loglik
}
```

#### 3. Flere likelihood implementeringer?

Lamperti-transformationerne, som vi skal bruge for $\kappa \neq 0$ afhænger af $t$.

#### 4. Datamangel

Har prøvet lidt af med $\exp$ på AMOC-fingerprint, men ellers synes jeg mit data (og jeg har fundet meget) ikke fitter særligt godt. Har dog kun prøvet med $nu = 1$.

```{r}
amoc_fit_data <- sqrt(exp(AMOCdata$AMOC2))
CIR_stationary_part_AMOC <- CIR_quadratic_martingale(
                            amoc_fit_data[AMOCdata$time<1924], 1/12
                            )
CIR_stationary_part_AMOC
```

```{r, echo=FALSE, message=FALSE}
tibble::tibble(obsSample = CIR_quadratic_martingale_resid(
                               CIR_stationary_part_estimated_param_martingale,
                               data = amoc_fit_data[AMOCdata$time<1924],
                               delta = 1/12)) |> ggplot2::ggplot(ggplot2::aes(sample = obsSample)) +
  ggplot2::geom_qq() + ggplot2::geom_qq_line()
```

```{r}
dynamic_part_true_param <- c(180, 1)
CIR_dynamic_part_AMOC <- optimize_dynamic_likelihood(
                            likelihood_fun = CIR_dynamic_likelihood,
                            data = amoc_fit_data[AMOCdata$time>=1924],
                            init_par = dynamic_part_true_param,
                            delta = 1/12,
                            alpha0 = CIR_stationary_part_AMOC[1],
                            mu0 = CIR_stationary_part_AMOC[2],
                            sigma = CIR_stationary_part_AMOC[3])
CIR_dynamic_part_AMOC
```

```{r, echo=FALSE, message=FALSE}
tibble::tibble(obsSample = CIR_dynamic_likelihood_resid(CIR_dynamic_part_AMOC,
                             data = amoc_fit_data[AMOCdata$time>=1924],
                             delta =1/12,
                             alpha0 = CIR_stationary_part_AMOC[1],
                             mu0 = CIR_stationary_part_AMOC[2],
                             sigma = CIR_stationary_part_AMOC[3])) |>
    ggplot2::ggplot(ggplot2::aes(sample = obsSample)) +
    ggplot2::geom_qq() + ggplot2::geom_qq_line()
```

#### 5. Generel valg af $\kappa$

Giver det mening at snakke om det, hvis der er tid? $\kappa = 1$ opfører sig i forvejen ikke altid super pænt...

#### 6. Brugen af splines, kovariater eller den parametriske form, jeg har fundet på.

Se R-script: "cubicSplines.R"
